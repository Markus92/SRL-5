//-----------------------------------------------------------------//
//--               SRL Resource Library                          --//
//--               » Math Routines                               --//
//-----------------------------------------------------------------//
// * procedure LoadCoSineArrays;                                   // * by Mutant Squirrle
// * function CreateTPAFromText(Txt : string; Chars : string) : TPointArray; // * by Raymond
// * function CreateTPAFromText(Txt : string; Chars : Integer) : TPointArray; // * by Raymond
// * function GetSplinePt(Points: TPointArray; Theta: Extended): TPoint; // * by BenLand100
// * function MakeSplinePath(Points: TPointArray; ThetaInc: Extended): TPointArray; // * by BenLand100
// * function MidPoints(Path: TPointArray; MaxDist: Integer): TPointArray; // * by BenLand100
// * function InAbstractBox(x1, y1, x2, y2, x3, y3, x4, y4: Integer; x, y: Integer): Boolean; // * by BenLand100
// * function inAngle(Origin: TPoint; Angle1, Angle2, Radius1, Radius2: Extended; X, Y: Integer): Boolean; // * by BenLand100
// * function Sine(degrees: Integer): Extended;                    // * by ???
// * function Cose(degrees: Integer): Extended;                    // * by ???
// * function MMToMS(MM: TPoint): TPoint;                          // * by N1ke!
// * procedure DeleteValueInStrArray(var Arr: TStringArray; ValuePosition: Integer); // * by EvilChicken!
// * procedure DeleteValueInIntArray(var Arr: TIntegerArray; ValuePosition: Integer); // * by EvilChicken!
// * procedure DeleteValueInFloatArray(var Arr: TExtendedArray; ValuePosition: Integer); // * by EvilChicken!
// * procedure DeleteValueInBoolArray(var Arr: TBooleanArray; ValuePosition: Integer); // * by EvilChicken!

var
   SineArray, Cosearray: array[0..360] of Extended;
   
{*******************************************************************************
procedure LoadCoSineArrays;
By: Mutant Squirrle
Description: Loads arrays for use with Radial- and LinearWalk.
*******************************************************************************}
procedure LoadCoSineArrays;
var
  i: Integer;
begin
  for i := 0 to 360 do
  begin
    Sinearray[i] := Sin(i * Pi / 180);
    Cosearray[i] := Cos(i * Pi / 180);
  end;
end;

{*******************************************************************************
function CreateTPAFromText(Txt : string; Chars : string) : TPointArray;
By: MastaRaymond
Description: Returns the TPointArray of the inputted Text. Needs Wizzyplugin
*******************************************************************************}
function CreateTPAFromText(Txt : string; Chars : string) : TPointArray;
var
  w,h : integer;
begin
  result := TPAFromText(Txt,Chars,w,h);
end;

{*******************************************************************************
function GetSplinePt(Points: TPointArray; Theta: Extended): TPoint;
By: BenLand100
Description: Returns the point on a spline, defined by control points Points, at Theta
*******************************************************************************}
function GetSplinePt(Points: TPointArray; Theta: Extended): TPoint;
var
  i, n: Integer;
  XTemp, YTemp: Extended;
begin
  n := GetArrayLength(Points) - 1;
  for i := 0 to n do
  begin
    XTemp := XTemp + (BinCoe(n, i) * Points[i].x * Pow((1 - Theta), n - i) *
      Pow(Theta, i));
    YTemp := YTemp + (BinCoe(n, i) * Points[i].y * Pow((1 - Theta), n - i) *
      Pow(Theta, i));
  end;
  Result.x := Round(XTemp);
  Result.y := Round(YTemp);
end;

{*******************************************************************************
function MakeSplinePath(Points: TPointArray; ThetaInc: Extended): TPointArray;
By: BenLand100
Description: Returns a spline, defined by control points Points, incrementing theta by ThetaInc
*******************************************************************************}
function MakeSplinePath(Points: TPointArray; ThetaInc: Extended): TPointArray;
var
  i: Integer;
  t: Extended;
  temp, last: TPoint;
  done: Boolean;
begin
  repeat
    if t >= 1 then
    begin
      t := 1;
      done := True;
    end;
    temp := GetSplinePt(Points, t);
    if ((temp.x <> last.x) and (temp.y <> last.y)) then
    begin
      i := i + 1;
      SetArrayLength(Result, i);
      Result[i - 1] := temp;
      last := temp;
    end;
    t := t + ThetaInc;
  until (done);
end;

{*******************************************************************************
function MidPoints(Path: TPointArray; MaxDist: Integer): TPointArray;
By: BenLand100
Description: Adds midpoints to Path so no distance on it is greater than MaxDist
*******************************************************************************}
function MidPoints(Path: TPointArray; MaxDist: Integer): TPointArray;
var
  i, c: Integer;
  last: TPoint;
  done: Boolean;
begin
  if (getarraylength(path) > 0) then
  begin
    repeat
      last := Path[0];
      done := True;
      for i := 1 to GetArrayLength(Path) - 1 do
      begin
        if Sqrt(Pow((Path[i].x - last.x), 2) + Pow((Path[i].y - last.y), 2)) >
          MaxDist then
        begin
          done := False;
          SetArrayLength(Path, GetArrayLength(Path) + 1);
          for c := GetArrayLength(Path) - 1 downto i + 1 do
          begin
            Path[c] := Path[c - 1];
          end;
          Path[i].x := Round((last.x + Path[i + 1].x) / 2);
          Path[i].y := Round((last.y + Path[i + 1].y) / 2);
        end;
        last := Path[i];
      end;
    until (done);
  end;
  Result := Path;
end;

{*******************************************************************************
function InAbstractBox(x1, y1, x2, y2, x3, y3, x4, y4: Integer; x, y: Integer): Boolean;
By: BenLand100
Description: Returns true if point x, y is in an abstract box defined by x1, y1, x2, y2, x3, y3, x4, y4
An abstract box example:

x1, y1     x2, y2
   +--------+
    \         /
     \       /
      +--+
x4, y4    x3, y3
*******************************************************************************}
function InAbstractBox(x1, y1, x2, y2, x3, y3, x4, y4: Integer; x, y: Integer):
  Boolean;
var
  U, D, R, L: Boolean;
  UB, DB, LB, RB, UM, DM, LM, RM: Extended;
begin
  UM := (-y1 - -y2) div (x1 - x2);
  DM := (-y4 - -y3) div (x4 - x3);
  if x1 - x4 <> 0 then
  begin
    LM := (-y1 - -y4) div (x1 - x4);
  end else
  begin
    LM := Pi;
  end;
  if x2 - x3 <> 0 then
  begin
    RM := (-y2 - -y3) div (x2 - x3);
  end else
  begin
    RM := Pi;
  end;
  UB := -(UM * x1) + -y1;
  RB := -(RM * x2) + -y2;
  DB := -(DM * x3) + -y3;
  LB := -(LM * x4) + -y4;
  if (UM * x + UB >= -y) then U := True;
  if (DM * x + DB <= -y) then D := True;
  if (RM <> Pi) and (RM >= 0) and (RM * x + RB <= -y) then R := True;
  if (RM <> Pi) and (RM < 0) and (RM * x + RB >= -y) then R := True;
  if (RM = Pi) and (x < x2) then R := True;
  if (LM <> Pi) and (LM >= 0) and (LM * x + LB >= -y) then L := True;
  if (LM <> Pi) and (LM < 0) and (LM * x + LB <= -y) then L := True;
  if (LM = Pi) and (x > x1) then L := True;
  if U and D and L and R then Result := True;
end;

{*******************************************************************************
function Sine(degrees: Integer): Extended;
By: ???
Description:
*******************************************************************************}
function Sine(Degrees: Integer): Extended;
begin
  Result := sinearray[Trunc(FixD(Degrees))];
end;

{*******************************************************************************
function Cose(degrees: Integer): Extended;
By: ???
Description:
*******************************************************************************}
function Cose(Degrees: Integer): Extended;
begin
  Result := cosearray[Trunc(FixD(Degrees))];
end;

{*******************************************************************************
function MMToMS(MM: TPoint): TPoint;
By: N1ke!
Description: Turns a Minimap point into a close MS point.
*******************************************************************************}
function MMToMS(MM: TPoint): TPoint;
var
  X, Y: Integer;
  Dis: TPoint;
begin
  X := ((MM.X - 647));
  Y := ((MM.Y - 84));

  Dis := Point( (MMCX - MM.X)*-1, (MMCY - MM.Y)*-1);
  Result := Point(Round((259.5 + X)+ Dis.X*10), Round((170.0 + Y)+ Dis.Y*6.5));

  If not IntInBox(Result.X, Result.Y, IntToBox(MSX1, MSY1, MSX2, MSY2)) then
    Result := Point(-1, -1);
end;

{*******************************************************************************
procedure DeleteValueInStrArray(var Arr: TStringArray; ValuePosition: Integer);
By: EvilChicken!
Description: Deletes value with ValuePosition in "Arr" string array.
*******************************************************************************}
procedure DeleteValueInStrArray(var Arr: TStringArray; ValuePosition: Integer);
var
  ArrLen, I: Integer;
begin
  ArrLen := High(Arr);
  for I := ValuePosition to ArrLen - 1 do
    Swap(Arr[I], Arr[I + 1]);
  SetArrayLength(Arr, ArrLen);
end;

{*******************************************************************************
procedure DeleteValueInIntArray(var Arr: TIntegerArray; ValuePosition: Integer);
By: EvilChicken!
Description: Deletes value with ValuePosition in "Arr" Integer array.
*******************************************************************************}
procedure DeleteValueInIntArray(var Arr: TIntegerArray; ValuePosition: Integer);
var
  ArrLen, I: Integer;
begin
  ArrLen := High(Arr);
  for I := ValuePosition to ArrLen - 1 do
    Swap(Arr[I], Arr[I + 1]);
  SetArrayLength(Arr, ArrLen);
end;

{*******************************************************************************
procedure DeleteValueInFloatArray(var Arr: TExtendedArray; ValuePosition: Integer);
By: EvilChicken!
Description: Deletes value with ValuePosition in "Arr" Float array.
*******************************************************************************}
procedure DeleteValueInFloatArray(var Arr: TExtendedArray; ValuePosition: Integer);
var
  ArrLen, I: Integer;
begin
  ArrLen := High(Arr);
  for I := ValuePosition to ArrLen - 1 do
    Swap(Arr[I], Arr[I + 1]);
  SetArrayLength(Arr, ArrLen);
end;

{*******************************************************************************
procedure DeleteValueInBoolArray(var Arr: TBooleanArray; ValuePosition: Integer);
By: EvilChicken!
Description: Deletes value with ValuePosition in "Arr" Boolean array.
*******************************************************************************}
procedure DeleteValueInBoolArray(var Arr: array of boolean; ValuePosition: Integer);
var
  ArrLen, I: Integer;
begin
  ArrLen := High(Arr);
  for I := ValuePosition to ArrLen - 1 do
    Swap(Arr[I], Arr[I + 1]);
  SetArrayLength(Arr, ArrLen);
end;

{*******************************************************************************
procedure DeleteValueInTPA(var Arr: TPointArray; ValuePosition: Integer);
By: EvilChicken! & Coh3n
Description: Deletes value with ValuePosition in "Arr" TPointArray.
*******************************************************************************}
procedure DeleteValueInTPA(var Arr: TPointArray; ValuePosition: Integer);
var
  ArrLen, I: Integer;
begin
  ArrLen := High(Arr);
  for I := ValuePosition to ArrLen - 1 do
    tSwap(Arr[I], Arr[I + 1]);
  SetArrayLength(Arr, ArrLen);
end;

{*******************************************************************************
procedure DeleteValueInATPA(var Arr: T2DPointArray; ValuePosition: Integer);
By: EvilChicken! & Coh3n
Description: Deletes value with ValuePosition in "Arr" T2DPointArray.
*******************************************************************************}
procedure DeleteValueInATPA(var Arr: T2DPointArray; ValuePosition: Integer);
var
  ArrLen, I: Integer;
begin
  ArrLen := High(Arr);
  for I := ValuePosition to ArrLen - 1 do
    tpaSwap(Arr[I], Arr[I + 1]);
  SetArrayLength(Arr, ArrLen);
end;

{*******************************************************************************
function BoxClosestPoint(p : TPoint; b : TBox) : TPoint;
By: Raym0nd
Description: There are 'nine' places where the point can be (relative to a box)..
The middle, 5, is the box itself.
The rest looks like this:
1 | 2 | 3
----------
4 | 5 | 6
---------
7 | 8 | 9

Place 9 means it's past the b.x2, and past the b.y2, therefore the smallest dist between the point
and the box is the distance between the point and the box's x2,y2 coordinate.
*******************************************************************************}

function BoxClosestPoint(p : TPoint; b : TBox) : TPoint;
var
  column,row,place : integer;
begin
  result := Point(-1,-1);
  if p.x < B.X1 then
    Column := 1
  else if p.x > b.x2 then
    Column := 3
  else
    Column := 2;
  if p.y < b.y1 then
    row := 1
  else if p.y > b.y2 then
    row := 3
  else
    row := 2;
  place := (row-1)* 3 + column;
  case Place of
    1 : Result := Point(b.x1,b.y1);
    2 : Result := Point(p.x,b.y1);
    3 : Result := point(b.x2,b.y1);
    4 : Result := point(b.x1,p.y);
    5 : Result := p;
    6 : Result := point(b.x2,p.y);
    7 : Result := point(b.x1,b.y2);
    8 : Result := point(p.x,b.y2);
    9 : Result := point(b.x2,b.y2);
  end;
end;

{*******************************************************************************
function RandomPointBoxEx(p : TPoint; b : TBox; extraDist : integer) : TPoint;
By: Raym0nd
Description: Returns a point in the box which is 'aimed' near the TPoint given..
Basically it only allows points that lay within the extradist from the closest point to be returned.
Practical example: Invetory Box.. When your mouse is on the right of an inv item, you don't want to
click on the left of the box.
*******************************************************************************}
function RandomPointBoxEx(p : TPoint; b : TBox; extraDist : integer) : TPoint;
var
  TPA : TPointArray;
  Dist : integer;
  ClosestPoint : TPoint;
begin
  if PointInBox(p,b) then
  begin
    result := p;
    exit;
  end;
  ClosestPoint := BoxClosestPoint(p,b);
  Dist := Distance(p.x,p.y,ClosestPoint.x,ClosestPoint.y);
  TPA := TPAFromBox(b);
  FilterPointsDist(TPA,0,dist+extraDist,p.x,p.y);
  if length(TPA) < 1 then
    result := point(RandomRange(b.X1,b.x2),RandomRange(b.y1,b.y2))
  else
    result := TPA[random(length(tpa))];
end;
{*******************************************************************************
function MiddleBox(b : TBox) : TPoint;
By: Raym0nd
Description: Returns the middle of the box.
*******************************************************************************}
function MiddleBox(b : TBox) : TPoint;
begin
  result := point((b.x2+b.x1) div 2,(b.y2+b.y1) div 2);
end;

{*******************************************************************************
function MSI_GroupDigits(n: integer; token: String): String;
By: PriSoner and Nava2
Description: Formats an integer into groups of 3 seperated by `token' and
             returns a formatted string (i.e 1234567 would become 1,234,567)
*******************************************************************************}
function GroupDigits(n: integer; token: String): String;
var
  b: integer;
begin
  Result := IntToStr(n);
  b := length(Result) + 1;
  if b > 3 then
  repeat
    b := b - 3;
    if b > 1 then
      insert(token, Result, b);
  until (b < 3);
end;
